import { Room, TextStreamReader } from "livekit-client";
import { DataTopic } from "@/agent-sdk/external-deps/components-js";
import { TextStreamInfo } from "@/agent-sdk/external-deps/client-sdk-js";

import { type ReceivedMessage, type ReceivedTranscriptionMessage } from "..";
import MessageReceiver from "./MessageReceiver";
import { ParticipantAttributes } from "@/agent-sdk/lib/participant-attributes";

/**
  * Processes new `lk.transcription` data stream events generated by the agent for both user and
  * LLM generated speach and generates corresponding `TranscriptionReceivedMessage`s.
  *
  * For agent messages, a new text stream is emitted for each message, and the stream is closed when the message is finalized.
  * Each agent message is delivered in chunks which must be accumulated and published into the message stream.
  *
  * For user messages, the full transcription is sent each time, but may be updated until finalized.
  *
  * The `lk.segment_id` attribute is stable and unique across the lifetime of the message.
  *
  * Example agent generated transcriptions:
  * ```
  * { segment_id: "1", content: "Hello" }
  * { segment_id: "1", content: " world" }
  * { segment_id: "1", content: "!" }
  * { segment_id: "2", content: "Hello" }
  * { segment_id: "2", content: " Apple" }
  * { segment_id: "2", content: "!" }
  * ```
  *
  * Example user generated transcriptions:
  * ```
  * { segment_id: "3", content: "Hello" }
  * { segment_id: "3", content: "Hello world!" }
  * { segment_id: "4", content: "Hello" }
  * { segment_id: "4", content: "Hello Apple!" }
  * ```
  */
export default class TranscriptionMessageReceiver extends MessageReceiver {
  room: Room;
  inFlightMessages: Array<ReceivedTranscriptionMessage> = [];

  constructor(room: Room) {
    super();
    this.room = room;
  }

  async start() {
    const textStreamHandler = async (reader: TextStreamReader, participantInfo: { identity: string }) => {
      const transcriptionSegmentId = reader.info.attributes?.[ParticipantAttributes.TranscriptionSegmentId];
      const isTranscription = Boolean(transcriptionSegmentId);
      const isFinal = reader.info.attributes?.[ParticipantAttributes.TranscriptionFinal] === 'true';

      let currentStreamId = reader.info.id;

      // Find and update the stream in our array
      let messageIndex = this.inFlightMessages.findIndex((message) => {
        if (message.content.streamInfo.id === reader.info.id) {
          return true;
        }
        if (isTranscription && transcriptionSegmentId === message.content.streamInfo.attributes?.[ParticipantAttributes.TranscriptionSegmentId]) {
          return true;
        }
        return false;
      });

      // FIXME: I think there may need to be some error handling logic to ensure the below for await
      // properly exposes errors via `this.closeWithError`
      for await (const chunk of reader) {
        const existingMessage = this.inFlightMessages[messageIndex];
        if (existingMessage) {
          if (existingMessage.content.streamInfo.id === currentStreamId) {
            // Stream hasn't changed, just append content
            const updatedMessage = this.appendInFlightMessageText(messageIndex, chunk, reader.info);
            this.enqueue(updatedMessage);
          } else {
            // Stream has changed, so fully replace content
            const updatedMessage = this.replaceInFlightMessageText(messageIndex, chunk, reader.info);
            this.enqueue(updatedMessage);
          }

        } else {
          // Handle case where stream ID wasn't found (new message)
          const message: ReceivedMessage = {
            id: reader.info.id,
            direction: 'inbound',
            timestamp: new Date(reader.info.timestamp),
            content: {
              type: 'transcription',
              text: chunk,
              participantInfo,
              streamInfo: reader.info,
            },
          };
          this.inFlightMessages.push(message);
          messageIndex = this.inFlightMessages.length-1;
          this.enqueue(message);
        }
      }

      if (isFinal) {
        this.inFlightMessages.splice(messageIndex, 1);
        console.log('!! MESSAGE DONE!', this.inFlightMessages);
      }
    };
    this.room.registerTextStreamHandler(DataTopic.TRANSCRIPTION, textStreamHandler);

    return () => {
      this.room.unregisterTextStreamHandler(DataTopic.TRANSCRIPTION);
    };
  }

  private replaceInFlightMessageText(messageIndex: number, text: string, streamInfo: TextStreamInfo) {
    this.inFlightMessages[messageIndex] = {
      ...this.inFlightMessages[messageIndex],
      content: {
        ...this.inFlightMessages[messageIndex].content,
        text,
        streamInfo,
      },
    };
    return this.inFlightMessages[messageIndex];
  }
  private appendInFlightMessageText(messageIndex: number, text: string, streamInfo: TextStreamInfo) {
    this.inFlightMessages[messageIndex] = {
      ...this.inFlightMessages[messageIndex],
      content: {
        ...this.inFlightMessages[messageIndex].content,
        text: this.inFlightMessages[messageIndex].content.text + text,
        streamInfo,
      },
    };
    return this.inFlightMessages[messageIndex];
  }
}
